import { ipcRenderer } from 'electron';
import logger from 'electron-log';
import fs from 'fs-extra';
import { v4 } from 'uuid';
import { WorkspaceEventTypes } from '@advanced-rest-client/arc-events';

/** @typedef {import('@advanced-rest-client/arc-events').WorkspaceReadEvent} WorkspaceReadEvent */
/** @typedef {import('@advanced-rest-client/arc-events').WorkspaceWriteEvent} WorkspaceWriteEvent */
/** @typedef {import('@advanced-rest-client/arc-types').Workspace.DomainWorkspace} DomainWorkspace */
/** @typedef {import('@advanced-rest-client/arc-types').Workspace.LegacyWorkspace} LegacyWorkspace */

export const readHandler = Symbol('readHandler');
export const writeHandler = Symbol('writeHandler');
export const getFileLocation = Symbol('getFileLocation');

/**
 * A class that manipulates the content of the workspace file.
 * The UI thread is not aware of the location of the workspace file. It only receives an autogenerated id by the `WindowManager`.
 * This class needs to ask where the file is located. This is done so no other script other than the one loaded in the pre-load script
 * can read the actual location of the file. 
 */
export class WorkspaceManager {
  /** 
   * @type {string} The read location of the workspace file.
   */
  #file = undefined;

  /** 
   * @type {*}
   */
  #writeTimeout = undefined;

  /**
   * @param {string=} id The identifier of the workspace generated by the window manager. If not set the default file is used.
   */
  constructor(id) {
    this.id = id;
    /**
     * Store data debounce timer.
     * By default it's 500 ms.
     * @type {Number}
     */
    this.timeout = 500;

    this[readHandler] = this[readHandler].bind(this);
    this[writeHandler] = this[writeHandler].bind(this);
  }

  listen() {
    window.addEventListener(WorkspaceEventTypes.read, this[readHandler]);
    window.addEventListener(WorkspaceEventTypes.write, this[writeHandler]);
  }

  /**
   * @param {WorkspaceReadEvent} e 
   */
  [readHandler](e) {
    e.detail.result = this.read();
  }

  /**
   * @param {WorkspaceWriteEvent} e 
   */
  [writeHandler](e) {
    const { contents } = e.detail;
    e.detail.result = this.write(contents);
  }

  /**
   * @returns {Promise<DomainWorkspace>} The current state of the workspace.
   */
  async read() {
    const file = await this[getFileLocation]();
    await fs.ensureFile(file);
    let result; 
    try {
      result = await fs.readJSON(file, { throws: false });
    } catch (e) {
      logger.error(`Workspace file read error for file ${file}`);
    }
    return this.processWorkspaceInput(result);
  }

  /**
   * Stores the state to a file.
   * @param {DomainWorkspace} workspace The workspace data to store.
   */
  async write(workspace) {
    if (this.#writeTimeout) {
      clearTimeout(this.#writeTimeout);
      this.#writeTimeout = undefined;
    }
    const file = await this[getFileLocation]();
    try {
      await fs.ensureFile(file);
      await fs.writeJSON(file, workspace);
    } catch (e) {
      logger.error(`Workspace file write error to file ${file}`);
    }
  }

  /**
   * Stores the state to a file.
   * @param {DomainWorkspace} workspace The workspace data to store.
   */
  writeAsync(workspace) {
    if (this.#writeTimeout) {
      clearTimeout(this.#writeTimeout);
    }
    this.#writeTimeout = setTimeout(() => this.write(workspace), this.timeout);
  }

  /**
   * @returns {Promise<string>}
   */
  async [getFileLocation]() {
    if (this.#file) {
      return this.#file;
    }
    const location = await ipcRenderer.invoke('workspace-get-location', this.id);
    this.#file = location;
    return location;
  }

  /**
   * If needed it upgrades the schema to the current one.
   * It creates a new workspace if it detects that the input is invalid.
   * @param {any} input The data read from the file.
   * @returns {DomainWorkspace} Processed workspace data
   */
  processWorkspaceInput(input) {
    if (!input) {
      return this.createDefaultWorkspace();
    }
    if (input.kind === 'ARC#DomainWorkspace') {
      return input;
    }
    const typedLegacy = /** @type LegacyWorkspace */ (input);
    if (Array.isArray(typedLegacy.requests)) {
      return this.upgradeLegacyWorkspace(typedLegacy);
    }
    return this.createDefaultWorkspace();
  }

  /**
   * Creates an empty workspace definition.
   * @returns {DomainWorkspace} Processed workspace data
   */
  createDefaultWorkspace() {
    return {
      kind: 'ARC#DomainWorkspace',
      id: v4(),
      readOnly: false,
    };
  }

  /**
   * @param {LegacyWorkspace} old
   * @returns {DomainWorkspace} Processed workspace data
   */
  upgradeLegacyWorkspace(old) {
    const info = this.createDefaultWorkspace();
    info.meta = {
      kind: 'ARC#ThingMeta',
    };
    if (typeof old.description === 'string') {
      info.meta.description = old.description;
    }
    if (typeof old.version === 'string') {
      info.meta.version = old.version;
    }
    if (typeof old.published === 'string') {
      info.meta.published = old.published;
      info.meta.updated = old.published;
    }
    if (typeof old.version === 'string') {
      info.meta.version = old.version;
    }
    if (old.provider) {
      info.provider = old.provider;
      info.provider.kind = 'ARC#Provider';
    }
    if (typeof old.selected === 'number') {
      info.selected = old.selected;
    }
    if (Array.isArray(old.variables)) {
      info.variables = old.variables;
    }
    if (Array.isArray(old.requests)) {
      info.requests = old.requests;
    }
    return info;
  }
}
